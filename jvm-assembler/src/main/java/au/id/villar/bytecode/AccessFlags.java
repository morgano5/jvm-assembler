package au.id.villar.bytecode;

public class AccessFlags {

    public static final short ACC_PUBLIC =       0x0001; // Declared public; may be accessed from outside its package.
    public static final short ACC_PRIVATE =      0x0002; // Declared private; usable only within the defining class.
    public static final short ACC_PROTECTED =    0x0004; // Declared protected; may be accessed within subclasses.
    public static final short ACC_STATIC =       0x0008; // Declared static.
    public static final short ACC_FINAL =        0x0010; // Declared final; for classes: no subclasses allowed; for fields: never directly assigned to after object construction; for methods: must not be overridden.
    public static final short ACC_SUPER =        0x0020; // Treat superclass methods specially when invoked by the invokespecial instruction.
    public static final short ACC_VOLATILE =     0x0040; // Declared volatile; cannot be cached.
    public static final short ACC_TRANSIENT =    0x0080; // Declared transient; not written or read by a persistent object manager.
    public static final short ACC_NATIVE =       0x0100; // Declared native; implemented in a language other than Java.
    public static final short ACC_INTERFACE =    0x0200; // Is an interface, not a class.
    public static final short ACC_ABSTRACT =     0x0400; // Declared abstract; for classes: must not be instantiated; for methods: no implementation is provided.
    public static final short ACC_STRICT =       0x0800; // Declared strictfp; floating-point mode is FP-strict.
    public static final short ACC_SYNTHETIC =    0x1000; // Declared synthetic; not present in the source code.
    public static final short ACC_ANNOTATION =   0x2000; // Declared as an annotation type.
    public static final short ACC_ENUM =         0x4000; // Declared as an enum type (classes) or as an element of an enum (fields).
    public static final short ACC_MODULE =       (short)0x8000; // Is a module, not a class or interface.
    public static final short ACC_MANDATED =     (short)0x8000;

    public static final short ACC_SYNCHRONIZED = 0x0020; // Declared synchronized; invocation is wrapped by a monitor use.
    public static final short ACC_BRIDGE =       0x0040; // A bridge method, generated by the compiler.
    public static final short ACC_VARARGS =      0x0080; // Declared with variable number of arguments.

    private final short flags;
    private final boolean method;

    public static boolean hasFlag(short testingFlags, short flagConstant) {
        return (testingFlags & flagConstant) != 0;
    }

    public AccessFlags(short flags, boolean method) {
        this.flags = flags;
        this.method = method;
    }

    public boolean isPublic() {
        return hasFlag(flags, ACC_PUBLIC);
    }

    public boolean isPrivate() {
        return hasFlag(flags, ACC_PRIVATE);
    }

    public boolean isProtected() {
        return hasFlag(flags, ACC_PROTECTED);
    }

    public boolean isStatic() {
        return hasFlag(flags, ACC_STATIC);
    }

    public boolean isFinal() {
        return hasFlag(flags, ACC_FINAL);
    }

    public boolean isSuper() {
        return !method && hasFlag(flags, ACC_SUPER);
    }

    public boolean isVolatile() {
        return !method && hasFlag(flags, ACC_VOLATILE);
    }

    public boolean isTransient() {
        return !method && hasFlag(flags, ACC_TRANSIENT);
    }

    public boolean isNative() {
        return hasFlag(flags, ACC_NATIVE);
    }

    public boolean isInterface() {
        return hasFlag(flags, ACC_INTERFACE);
    }

    public boolean isAbstract() {
        return hasFlag(flags, ACC_ABSTRACT);
    }

    public boolean isStrict() {
        return hasFlag(flags, ACC_STRICT);
    }

    public boolean isSynthetic() {
        return hasFlag(flags, ACC_SYNTHETIC);
    }

    public boolean isAnnotation() {
        return hasFlag(flags, ACC_ANNOTATION);
    }

    public boolean isEnum() {
        return hasFlag(flags, ACC_ENUM);
    }

    public boolean isModule() {
        return hasFlag(flags, ACC_MODULE);
    }

    public boolean isSynchronized() {
        return method && hasFlag(flags, ACC_SYNCHRONIZED);
    }

    public boolean isBridge() {
        return method && hasFlag(flags, ACC_BRIDGE);
    }

    public boolean isVargars() {
        return method && hasFlag(flags, ACC_VARARGS);
    }

    public boolean isMandated() {
        return method && hasFlag(flags, ACC_MANDATED);
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("AccessFlags{");
        if(isPrivate()) builder.append(" Private");
        if(isProtected()) builder.append(" Protected");
        if(isStatic()) builder.append(" Static");
        if(isFinal()) builder.append(" Final");
        if(isSuper()) builder.append(" Super");
        if(isVolatile()) builder.append(" Volatile");
        if(isTransient()) builder.append(" Transient");
        if(isNative()) builder.append(" Native");
        if(isInterface()) builder.append(" Interface");
        if(isAbstract()) builder.append(" Abstract");
        if(isStrict()) builder.append(" Strict");
        if(isSynthetic()) builder.append(" Synthetic");
        if(isAnnotation()) builder.append(" Annotation");
        if(isEnum()) builder.append(" Enum");
        if(isModule()) builder.append(" Module");
        if(isSynchronized()) builder.append(" Synchronized");
        if(isBridge()) builder.append(" Bridge");
        if(isVargars()) builder.append(" Vargars");
        if(isMandated()) builder.append(" Mandated");
        builder.append("}");
        return builder.toString();
    }
}
