package au.id.villar.bytecode;

import static au.id.villar.bytecode.AccessFlags.FlagsType.CLASS;
import static au.id.villar.bytecode.AccessFlags.FlagsType.FIELD;
import static au.id.villar.bytecode.AccessFlags.FlagsType.METHOD;
import static au.id.villar.bytecode.AccessFlags.FlagsType.INNER_CLASS;
import static au.id.villar.bytecode.AccessFlags.FlagsType.METHOD_PARAMETERS;

public class AccessFlags {

    private static final short ACC_PUBLIC =       0x0001; // Declared public; may be accessed from outside its package.
    private static final short ACC_PRIVATE =      0x0002; // Declared private; usable only within the defining class.
    private static final short ACC_PROTECTED =    0x0004; // Declared protected; may be accessed within subclasses.
    private static final short ACC_STATIC =       0x0008; // Declared static.
    private static final short ACC_FINAL =        0x0010; // Declared final; for classes: no subclasses allowed; for fields: never directly assigned to after object construction; for methods: must not be overridden.
    private static final short ACC_SUPER =        0x0020; // Treat superclass methods specially when invoked by the invokespecial instruction.
    private static final short ACC_VOLATILE =     0x0040; // Declared volatile; cannot be cached.
    private static final short ACC_TRANSIENT =    0x0080; // Declared transient; not written or read by a persistent object manager.
    private static final short ACC_NATIVE =       0x0100; // Declared native; implemented in a language other than Java.
    private static final short ACC_INTERFACE =    0x0200; // Is an interface, not a class.
    private static final short ACC_ABSTRACT =     0x0400; // Declared abstract; for classes: must not be instantiated; for methods: no implementation is provided.
    private static final short ACC_STRICT =       0x0800; // Declared strictfp; floating-point mode is FP-strict.
    private static final short ACC_SYNTHETIC =    0x1000; // Declared synthetic; not present in the source code.
    private static final short ACC_ANNOTATION =   0x2000; // Declared as an annotation type.
    private static final short ACC_ENUM =         0x4000; // Declared as an enum type (classes) or as an element of an enum (fields).
    private static final short ACC_MODULE =       (short)0x8000; // Is a module, not a class or interface.
    private static final short ACC_MANDATED =     (short)0x8000;

    private static final short ACC_SYNCHRONIZED = 0x0020; // Declared synchronized; invocation is wrapped by a monitor use.
    private static final short ACC_BRIDGE =       0x0040; // A bridge method, generated by the compiler.
    private static final short ACC_VARARGS =      0x0080; // Declared with variable number of arguments.

    public enum FlagsType {
        CLASS, FIELD, METHOD, INNER_CLASS, METHOD_PARAMETERS;
    }

    private final short flags;
    private final FlagsType flagsType;

    public AccessFlags(short flags, FlagsType flagsType) {
        this.flagsType = flagsType;
        this.flags = flags;
    }

    public short getFlags() {
        return flags;
    }

    public boolean isPublic() {
        return hasFlagAndBelongsToOneClass(flags, ACC_PUBLIC, CLASS, FIELD, METHOD, INNER_CLASS);
    }

    public boolean isPrivate() {
        return hasFlagAndBelongsToOneClass(flags, ACC_PRIVATE, FIELD, METHOD, INNER_CLASS);
    }

    public boolean isProtected() {
        return hasFlagAndBelongsToOneClass(flags, ACC_PROTECTED, FIELD, METHOD, INNER_CLASS);
    }

    public boolean isStatic() {
        return hasFlagAndBelongsToOneClass(flags, ACC_STATIC, FIELD, METHOD, INNER_CLASS);
    }

    public boolean isFinal() {
        return hasFlagAndBelongsToOneClass(flags, ACC_FINAL, CLASS, METHOD, FIELD, INNER_CLASS, METHOD_PARAMETERS);
    }

    public boolean isSuper() {
        return hasFlagAndBelongsToOneClass(flags, ACC_SUPER, CLASS);
    }

    public boolean isVolatile() {
        return hasFlagAndBelongsToOneClass(flags, ACC_VOLATILE, FIELD);
    }

    public boolean isTransient() {
        return hasFlagAndBelongsToOneClass(flags, ACC_TRANSIENT, FIELD);
    }

    public boolean isNative() {
        return hasFlagAndBelongsToOneClass(flags, ACC_NATIVE, METHOD);
    }

    public boolean isInterface() {
        return hasFlagAndBelongsToOneClass(flags, ACC_INTERFACE, CLASS, INNER_CLASS);
    }

    public boolean isAbstract() {
        return hasFlagAndBelongsToOneClass(flags, ACC_ABSTRACT, CLASS, METHOD, INNER_CLASS);
    }

    public boolean isStrict() {
        return hasFlagAndBelongsToOneClass(flags, ACC_STRICT, METHOD);
    }

    public boolean isSynthetic() {
        return hasFlagAndBelongsToOneClass(flags, ACC_SYNTHETIC, CLASS, METHOD, FIELD, INNER_CLASS, METHOD_PARAMETERS);
    }

    public boolean isAnnotation() {
        return hasFlagAndBelongsToOneClass(flags, ACC_ANNOTATION, CLASS, INNER_CLASS);
    }

    public boolean isEnum() {
        return hasFlagAndBelongsToOneClass(flags, ACC_ENUM, CLASS, INNER_CLASS, FIELD);
    }

    public boolean isModule() {
        return hasFlagAndBelongsToOneClass(flags, ACC_MODULE, CLASS);
    }

    public boolean isSynchronized() {
        return hasFlagAndBelongsToOneClass(flags, ACC_SYNCHRONIZED, METHOD);
    }

    public boolean isBridge() {
        return hasFlagAndBelongsToOneClass(flags, ACC_BRIDGE, METHOD);
    }

    public boolean isVargars() {
        return hasFlagAndBelongsToOneClass(flags, ACC_VARARGS, METHOD);
    }

    public boolean isMandated() {
        return hasFlagAndBelongsToOneClass(flags, ACC_MANDATED, METHOD_PARAMETERS);
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder();
        builder.append("AccessFlags{").append(flagsType).append(" - ");
        if(isPublic()) builder.append(" Public");
        if(isPrivate()) builder.append(" Private");
        if(isProtected()) builder.append(" Protected");
        if(isStatic()) builder.append(" Static");
        if(isFinal()) builder.append(" Final");
        if(isSuper()) builder.append(" Super");
        if(isVolatile()) builder.append(" Volatile");
        if(isTransient()) builder.append(" Transient");
        if(isNative()) builder.append(" Native");
        if(isInterface()) builder.append(" Interface");
        if(isAbstract()) builder.append(" Abstract");
        if(isStrict()) builder.append(" Strict");
        if(isSynthetic()) builder.append(" Synthetic");
        if(isAnnotation()) builder.append(" Annotation");
        if(isEnum()) builder.append(" Enum");
        if(isModule()) builder.append(" Module");
        if(isSynchronized()) builder.append(" Synchronized");
        if(isBridge()) builder.append(" Bridge");
        if(isVargars()) builder.append(" Vargars");
        if(isMandated()) builder.append(" Mandated");
        builder.append("}");
        return builder.toString();
    }

    private boolean hasFlagAndBelongsToOneClass(short testingFlags, short flagConstant, FlagsType ... types) {
        for (FlagsType c : types) {
            if (flagsType == c) {
                return (testingFlags & flagConstant) != 0;
            }
        }
        return false;
    }
}
